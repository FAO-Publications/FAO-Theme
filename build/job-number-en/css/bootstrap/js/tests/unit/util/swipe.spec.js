import{clearFixture,getFixture}from"../../helpers/fixture";import EventHandler from"../../../src/dom/event-handler";import Swipe from"../../../src/util/swipe";import{noop}from"../../../src/util";describe("Swipe",(()=>{const{Simulator:e,PointerEvent:t}=window,n=t,o=Boolean(t);let i,a;const l=()=>{window.PointerEvent=null},s=()=>{window.PointerEvent=n},r=()=>{document.documentElement.ontouchstart=noop},c=()=>{delete document.documentElement.ontouchstart},p=(t,n={},o="touch")=>{e.setType(o);const i={deltaX:0,deltaY:0,...n};e.gestures.swipe(t,i)};beforeEach((()=>{i=getFixture();const e=["<style>","  #fixture .pointer-event {","    touch-action: pan-y;","  }","  #fixture div {","    width: 300px;","    height: 300px;","  }","</style>"].join("");i.innerHTML=`<div id="swipeEl"></div>${e}`,a=i.querySelector("div")})),afterEach((()=>{clearFixture(),c()})),describe("constructor",(()=>{it("should add touch event listeners by default",(()=>{r(),spyOn(Swipe.prototype,"_initEvents").and.callThrough();const e=new Swipe(a);expect(e._initEvents).toHaveBeenCalled()})),it("should not add touch event listeners if touch is not supported",(()=>{spyOn(Swipe,"isSupported").and.returnValue(!1),spyOn(Swipe.prototype,"_initEvents").and.callThrough();const e=new Swipe(a);expect(e._initEvents).not.toHaveBeenCalled()}))})),describe("Config",(()=>{it("Test leftCallback",(()=>new Promise((e=>{const t=jasmine.createSpy("spy");l(),r(),new Swipe(a,{leftCallback(){expect(t).not.toHaveBeenCalled(),s(),e()},rightCallback:t}),p(a,{pos:[300,10],deltaX:-300})})))),it("Test rightCallback",(()=>new Promise((e=>{const t=jasmine.createSpy("spy");l(),r(),new Swipe(a,{rightCallback(){expect(t).not.toHaveBeenCalled(),s(),e()},leftCallback:t}),p(a,{pos:[10,10],deltaX:300})})))),it("Test endCallback",(()=>new Promise((e=>{l(),r();let t=!0;new Swipe(a,{endCallback:()=>{t?t=!1:(expect().nothing(),s(),e())}}),p(a,{pos:[10,10],deltaX:300}),p(a,{pos:[300,10],deltaX:-300})}))))})),describe("Functionality on PointerEvents",(()=>{it("should not allow pinch with touch events",(()=>{e.setType("touch"),l(),c();const t=new Swipe(a),n=spyOn(t,"_handleSwipe");p(a,{pos:[300,10],deltaX:-300,deltaY:0,touches:2}),s(),expect(n).not.toHaveBeenCalled()})),it('should allow swipeRight and call "rightCallback" with pointer events',(()=>new Promise((e=>{if(!o)return expect().nothing(),void e();i.innerHTML+="#fixture .pointer-event { touch-action: none !important; }",r(),new Swipe(a,{rightCallback(){c(),expect().nothing(),e()}}),p(a,{deltaX:300},"pointer")})))),it('should allow swipeLeft and call "leftCallback" with pointer events',(()=>new Promise((e=>{if(!o)return expect().nothing(),void e();i.innerHTML+="#fixture .pointer-event { touch-action: none !important; }",r(),new Swipe(a,{leftCallback(){expect().nothing(),c(),e()}}),p(a,{pos:[300,10],deltaX:-300},"pointer")}))))})),describe("Dispose",(()=>{it("should call EventHandler.off",(()=>{r(),spyOn(EventHandler,"off").and.callThrough(),new Swipe(a).dispose(),expect(EventHandler.off).toHaveBeenCalledWith(a,".bs.swipe")})),it("should destroy",(()=>{const e=spyOn(i,"addEventListener").and.callThrough(),t=spyOn(EventHandler,"off").and.callThrough();r();const n=new Swipe(i),o=n._supportPointerEvents?[["pointerdown",jasmine.any(Function),jasmine.any(Boolean)],["pointerup",jasmine.any(Function),jasmine.any(Boolean)]]:[["touchstart",jasmine.any(Function),jasmine.any(Boolean)],["touchmove",jasmine.any(Function),jasmine.any(Boolean)],["touchend",jasmine.any(Function),jasmine.any(Boolean)]];expect(e.calls.allArgs()).toEqual(o),n.dispose(),expect(t).toHaveBeenCalledWith(i,".bs.swipe"),c()}))})),describe('"isSupported" static',(()=>{it('should return "true" if "touchstart" exists in document element)',(()=>{Object.defineProperty(window.navigator,"maxTouchPoints",(()=>0)),r(),expect(Swipe.isSupported()).toBeTrue()})),it('should return "false" if "touchstart" not exists in document element and "navigator.maxTouchPoints" are zero (0)',(()=>{Object.defineProperty(window.navigator,"maxTouchPoints",(()=>0)),c(),"ontouchstart"in document.documentElement?expect().nothing():expect(Swipe.isSupported()).toBeFalse()}))}))}));